{% extends 'base.html' %}

{% block title %}Home Page{% endblock %}

{% block content %}

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.23.2/dist/bootstrap-table.min.css">

<div class="container-fluid">

    <!-- Page title -->
    <div class="row">
        <div class="col-md-12">
            <h1 class="text-center">SOC-KG ORION</h1>
        </div>
    </div>

    <!-- Button group -->
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-12">
                <div class="d-flex justify-content-start" role="toolbar" aria-label="Toolbar with button groups">
                    <button id="open-modal-btn" class="btn btn-primary me-2">Add Node to Canvas</button>
                    <button id="load-ontology-btn" class="btn btn-primary me-2">Load Ontology</button>
                    <button id="Clear-canas-btn" type="button" class="btn btn-danger">Clear Canvas</button>
                </div>
            </div>
        </div>
    </div>



    <!-- Network canvas -->
    <div style="display: flex; height: 80vh;">
        <div id="mynetwork" style="flex-grow: 1; border: 5px solid lightgray;"></div>
    </div>

    <!-- Modal backdrop -->
    <div class="modal-backdrop" id="modal-backdrop"></div>

    <!-- Modal -->
    <div class="modal-body" id="search-modal">
        <div class="container-fluid">
            <div class="modal-header">
                <h3 class="modal-title">Search and Add Nodes</h3>
                <button type="button" class="btn btn-outline-dark" data-bs-dismiss="modal" aria-label="Close"
                    id="close-modal-btn">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>

            <hr>

            <table class="table table-striped table-light table-bordered table-hover" data-click-to-select="true"
                data-click-to-select="true">
                <thead id="table-head" class="thead-light">
                    <tr>
                        <th scope="col">#</th>
                        <th scope="col">Labels</th>
                        <th scope="col" data-field="instance_uri" data-sortable="true">instance_uri</th>
                        <th scope="col">Import</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- Default empty rows -->
                    <tr>
                        <td colspan="4" rowspan="10" style="text-align: center;">No data</td>
                    </tr>
                </tbody>
            </table>

            <!-- Pagination controls -->
            <nav aria-label="Page navigation">
                <ul class="pagination justify-content-center mt-3">
                    <li class="page-item">
                        <button class="page-link" id="prev-page">Previous</button>
                    </li>
                    <li class="page-item">
                        <span class="page-link" id="current-page">Page 1 of 1</span>
                    </li>
                    <li class="page-item">
                        <button class="page-link" id="next-page">Next</button>
                    </li>
                    <li class="page-item">
                        <input type="number" class="form-control" id="page-input" min="1" style="width: 70px;">
                    </li>
                    <li class="page-item">
                        <button class="page-link" id="go-to-page">Go</button>
                    </li>
                </ul>
            </nav>
        </div>
    </div>



    <button id="button" type="button" class="btn btn-primary btn-lg" data-bs-toggle="modal"
        data-bs-target="#modalTable">
        Launch modal table
    </button>
    <div id="modalTable" class="modal fade" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Modal table</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="input-group">
                    <select id="label-select" class="form-select aria-label=" Default select example">
                        <option selected>Select label</option>
                        <!-- Options will be added dynamically -->
                    </select>
                    <select id="property-select" class="form-select" aria-label="Default select example">
                        <option selected>Select property</option>
                    </select>
            
                    <input type="text" class="form-control" placeholder="Filter keyword">
                </div>
                
                <div class="container-fluid">
                    <table id="table" data-url="http://127.0.01:5000/get_node_instance_from_class_v2"
                        class="table table-light table-bordered table-hover" data-bs-dismiss="true" data-height="400"
                        data-toggle="'table"
                        data-side-pagination="server" data-pagination="true" data-search="true"
                        data-click-to-select="true" data-show-columns="true" data-show-refresh="true" ,
                        data-show-columns-toggle-all="true" data-show-pagination-switch="true" data-buttons="buttons"
                        data-search-highlight="true" show-full-screen="true" data-show-search-clear-button="true"
                        data-detail-view="true" data-detail-view-by-click="true" data-detail-view-icon="false">
                        <thead>
                            <tr>
                                <th data-field="state" data-checkbox="true"></th>
                                <th data-field="id" data-detail-formatter="detailFormatter">ID</th>
                                <th data-field="uri" data-detail-formatter="detailFormatter">Node URI</th>
                                <th data-field="property_value" data-sortable="true"
                                    data-detail-formatter="detailFormatter">Selected
                                    Property Value</th>
                            </tr>
                        </thead>
                    </table>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>


</div>

<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.23.2/dist/bootstrap-table.min.js"></script>

<script type="text/javascript">

    var $table = $('#table');
    var currentClassType = "WeatherObservation"; // Default class type
    var currentPropertyType = "snow"

    $(function () {
        $('#modalTable').on('shown.bs.modal', function () {
            $table.bootstrapTable('resetView')
        })
    })

    async function get_data_property_from_instance(node_uri) {
        const response = await fetch(`/get_data_property_from_instance?node_uri=${encodeURIComponent(node_uri)}`);
        if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
        }
        const data = await response.json();
        return data;
    }

    // When a row is expanded
    $('#table').on('expand-row.bs.table', async function (e, index, row, $detail) {
        // Show initial loading message
        $detail.html('Loading data from server...');

        try {
            // Fetch data properties for the given node URI
            const data = await get_data_property_from_instance(row.uri);

            // Format the fetched data as HTML (you can customize this format as needed)
            let detailHtml = '<ul>';
            for (const [key, value] of Object.entries(data)) {
                detailHtml += `<li><strong>${key}:</strong> ${value}</li>`;
            }
            detailHtml += '</ul>';

            // Update the detail section with the fetched data
            $detail.html(detailHtml);
        } catch (error) {
            // Handle any errors that occur during the fetch
            console.error('Error fetching data property:', error);
            $detail.html('Error fetching data.');
        }
    });

    // function get_data_property_from_instance(node_uri) {
    // return fetch(`/get_data_property_from_instance?node_uri=${encodeURIComponent(node_uri)}`)
    //     .then(response => {
    //         if (!response.ok) {
    //             throw new Error(`Server error: ${response.status}`);
    //         }
    //         return response.json();
    //     });
    // }

    // function detailFormatter(index, row) {
    //     get_data_property_from_instance(row.uri)
    //         .then(data => {
    //             // Update the DOM or display the data in another way, as it is asynchronous
    //             console.log('Data:', data);
    //             // Here, you could dynamically update the row detail or other UI elements
    //             return JSON.stringify(data);
    //         })
    //         .catch(error => {
    //             console.error('Error fetching data property:', error);
    //             document.getElementById(`detail-row-${index}`).innerHTML = 'Error fetching data';
    //         });

    //     return `Loading data for row ${index}...`; // Placeholder while the data is being fetched
    // }




    function initializeTable(classType, propertyType) {
        currentClassType = classType;
        currentPropertyType = propertyType;
        $table.bootstrapTable('destroy'); // Destroy existing table instance
        $table.bootstrapTable({
            // paginationLoadMore: true,
            queryParams: function (params) {
                // params.limit = 10000;
                // params.offset = (currentPage - 1) * itemsPerPage;
                params.class_type = currentClassType;
                params.property_name = currentPropertyType;
                return params;
            },
            // responseHandler: function (res) {
            //     return res;
            // },
            // Add any other table options here
        });
    }

    // Initial table setup
    $(function () {
        initializeTable(currentClassType, currentPropertyType);
    });

    // Function to update table when class type changes
    function updateTableClassType(newClassType, newPropertyType) {
        initializeTable(newClassType, newPropertyType);
    }

    // Event listener for class type change
    // // Assuming you have a select element with id 'classTypeSelect'
    // $('#classTypeSelect').on('change', function () {
    //     var newClassType = $(this).val();
    //     updateTableClassType(newClassType);
    // });

    // pagination variables
    let currentPage = 1;
    const itemsPerPage = 10;
    let totalItems = 0;


    // Get nodes and edges data from Flask
    const allNodesJson = {{ node_list | tojson | safe }};
    const allEdgesJson = {{ edge_list | tojson | safe }};

    // DOM element references
    const modal = document.getElementById("search-modal");
    const modalBackdrop = document.getElementById("modal-backdrop");
    const openModalBtn = document.getElementById("open-modal-btn");
    const closeModalBtn = document.getElementById("close-modal-btn");
    const clearCanvasBtn = document.getElementById("Clear-canas-btn");
    const loadOntologyBtn = document.getElementById("load-ontology-btn");
    const labelSelect = document.getElementById("label-select");
    const propertySelect = document.getElementById("property-select");
    const tableBody = document.getElementById("table-body");
    const prevPageBtn = document.getElementById("prev-page");
    const nextPageBtn = document.getElementById("next-page");
    const currentPageSpan = document.getElementById("current-page");
    const tableHead = document.getElementById("table-head");

    const pageInput = document.getElementById("page-input");
    const goToPageBtn = document.getElementById("go-to-page");
    // Add these event listeners
    goToPageBtn.addEventListener('click', goToInputPage);

    // Event listeners
    loadOntologyBtn.addEventListener('click', loadOntology);
    openModalBtn.addEventListener('click', openModal);
    closeModalBtn.addEventListener('click', closeModal);
    clearCanvasBtn.addEventListener('click', clearCanvas);
    labelSelect.addEventListener('change', handleLabelChange);
    propertySelect.addEventListener('change', handlePropertyChange);

    // Event listeners for pagination
    prevPageBtn.addEventListener('click', () => changePage(-1));
    nextPageBtn.addEventListener('click', () => changePage(1));

    // Close modal when clicking outside
    window.addEventListener('click', (event) => {
        if (event.target === modalBackdrop) {
            closeModal();
        }
    });

    // Populate label select
    const labelSelectList = {{ node_list | tojson | safe }}.map(node => node.label);
    populateSelect(labelSelect, labelSelectList);

    let network;

    function loadOntology(nodes, edges) {
        nodes = new vis.DataSet(allNodesJson);
        edges = new vis.DataSet(allEdgesJson);
        redrawAll(nodes, edges);
    }

    function openModal() {
        modal.style.display = "block";
        modalBackdrop.style.display = "block";
    }

    function closeModal() {
        modal.style.display = "none";
        modalBackdrop.style.display = "none";
    }

    function clearCanvas() {
        redrawAll(null, null);
    }

    async function handleLabelChange() {
        const selectedLabel = labelSelect.value;
        await populatePropertySelect(selectedLabel);
        currentPage = 1;
        await getTotalItemCount(selectedLabel);
        await populateNodeInstances(selectedLabel, null);
        updateTableClassType(selectedLabel, propertySelect.value);
    }

    async function handlePropertyChange() {
        const selectedProperty = propertySelect.value;
        // replace table head with selected property
        tableHead.innerHTML = `<tr><th scope="col">#</th><th scope="col">Labels</th><th scope="col">${selectedProperty}</th><th scope="col">Import</th></tr>`;
        await populateNodeInstances(labelSelect.value, propertySelect.value);
        updateTableClassType(labelSelect.value, selectedProperty);
    }

    async function getTotalItemCount(classType) {
        try {
            const response = await fetch(`/get_instance_count?class_type=${encodeURIComponent(classType)}`);
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            const data = await response.json();
            totalItems = data || 0;

        } catch (error) {
            console.error('Error fetching instance count:', error);
            totalItems = 0;
        }
    }

    async function getDataProperties(label) {
        try {
            const response = await fetch(`/get_data_properties_from_class?class_type=${encodeURIComponent(label)}`);
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching node instances:', error);
            return [];
        }
    }

    async function getNodesInstances(classType, selectedProperty, limit = itemsPerPage, offset = 0) {
        try {
            const response = await fetch(`/get_node_instance_from_class?class_type=${encodeURIComponent(classType)}&property_name=${encodeURIComponent(selectedProperty)}&limit=${limit}&offset=${offset}`);
            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching node instances:', error);
            return [];
        }
    }

    function populateSelect(selectElement, options) {
        // check if select element is property select
        if (selectElement === propertySelect) {
            // add default option
            options.unshift('instance_uri');
        }
        selectElement.innerHTML = options.map(option => `<option value="${option}">${option}</option>`).join('');
    }

    async function populatePropertySelect(selectedLabel) {
        const properties = await getDataProperties(selectedLabel);
        populateSelect(propertySelect, properties.map(prop => prop.name));
    }

    async function populateNodeInstances(selectedLabel, selectedProperty) {
        tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center;"><img src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExNGQ5ZjJ4azlrMzBuaTJ0Mnd2NHBoOGtpa3o3eXpvdHcwOHM3NG5haiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/TTMXOwinNDNv4qnm3Q/giphy.webp" alt="Loading..." width="50"></td></tr>';

        const offset = (currentPage - 1) * itemsPerPage;
        const nodesInstances = await getNodesInstances(selectedLabel, selectedProperty, itemsPerPage, offset);

        // replace instance with 'No data' if empty
        nodesInstances.forEach((instance, index) => {
            if (instance === 'NaN') {
                nodesInstances[index] = 'No data';
            }
        });
        var index = 0;
        tableBody.innerHTML = nodesInstances.map(instance => `
            <tr>
                <td>${++index + (currentPage - 1) * itemsPerPage}</td>
                <td>${selectedLabel}</td>
                <td>${instance}</td>
                <td><button class="btn btn-outline-primary">Import</button></td>
            </tr>
        `).join('');

        updatePaginationControls();
    }

    function updatePaginationControls() {
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        currentPageSpan.textContent = `Page ${currentPage} of ${totalPages}`;
        prevPageBtn.disabled = currentPage === 1;
        nextPageBtn.disabled = currentPage === totalPages;
    }

    // Modify the existing changePage function
    async function changePage(direction) {
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        const newPage = currentPage + direction;
        if (newPage > 0 && newPage <= totalPages) {
            currentPage = newPage;
            await populateNodeInstances(labelSelect.value, propertySelect.value);
        }
    }

    // Add these new functions
    async function goToPage(pageNumber) {
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        if (pageNumber > 0 && pageNumber <= totalPages) {
            currentPage = pageNumber;
            await populateNodeInstances(labelSelect.value, propertySelect.value);
        }
    }

    function goToInputPage() {
        const pageNumber = parseInt(pageInput.value);
        if (!isNaN(pageNumber)) {
            goToPage(pageNumber);
        }
    }

    // Initialize the network
    redrawAll(null, null);
    function redrawAll(nodeList, edgeList) {
        const container = document.getElementById("mynetwork");
        const options = {
            autoResize: true,
            height: "100%",
            width: "100%",
            locale: "en",
            nodes: {
                scaling: { min: 10, max: 30 },
                font: { size: 12, face: "Tahoma" },
                borderWidth: 3,
                shape: "circle",
            },
            edges: {
                width: 0.15,
                color: { inherit: "from" },
                smooth: { type: "continuous" },
            },
            physics: {
                barnesHut: {
                    gravitationalConstant: -7000,
                    centralGravity: 0,
                    springLength: 120,
                },
                minVelocity: 0.75
            },
            interaction: {
                tooltipDelay: 200,
                hideEdgesOnDrag: true,
                hideEdgesOnZoom: true,
                hover: true,
                hoverConnectedEdges: true,
                keyboard: {
                    enabled: true,
                    speed: { x: 10, y: 10, zoom: 0.02 },
                    bindToWindow: true,
                },
                navigationButtons: true,
            },
            layout: {
                randomSeed: '0.6220599341091104:1726193513099',
                improvedLayout: true,
            },
        };

        if (!nodeList || !edgeList) {
            nodeList = new vis.DataSet({});
            edgeList = new vis.DataSet({});
        }
        const data = { nodes: nodeList, edges: edgeList };
        network = new vis.Network(container, data, options);

        const networkCanvas = container.getElementsByTagName("canvas")[0];
        networkCanvas.style.cursor = "default";

        network.on("hoverNode", () => networkCanvas.style.cursor = "grab");
        network.on("blurNode", () => networkCanvas.style.cursor = "default");
        network.on("hoverEdge", () => networkCanvas.style.cursor = "grab");
        network.on("blurEdge", () => networkCanvas.style.cursor = "default");

        allNodes = nodeList.get({ returnType: "Object" });
    }
</script>
{% endblock %}